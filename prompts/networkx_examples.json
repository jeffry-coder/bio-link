[
  {
    "question": "Find the shortest path from patient '7c2e78bd-52cf-1fce-acc3-0ddd93104abe' to the condition 'Medication review due (situation)' (CODE: 314529007) through their encounters.",
    "code": "patient_id = \"patients/7c2e78bd-52cf-1fce-acc3-0ddd93104abe\"\ncondition_id = \"conditions/1\"  # Assuming this matches CODE: 314529007\n\ntry:\n    shortest_path = nx.shortest_path(G, source=patient_id, target=condition_id)\n    \n    # Get readable information for each node in the path\n    readable_path = []\n    for node in shortest_path:\n        node_info = G.nodes[node]\n        if node.startswith(\"patients/\"):\n            patient_name = f\"{node_info.get('FIRST', '')} {node_info.get('LAST', '')}\".strip() or 'Unknown'\n            readable_path.append(f\"{node} (Patient: {patient_name})\") \n        elif node.startswith(\"encounters/\"):\n            readable_path.append(f\"{node} (Encounter: {node_info.get('DESCRIPTION', 'Unknown')})\") \n        elif node.startswith(\"conditions/\"):\n            readable_path.append(f\"{node} (Condition: {node_info.get('DESCRIPTION', 'Unknown')})\") \n        else:\n            readable_path.append(node)\n    \n    print(f\"Shortest path: {readable_path}\")\nexcept nx.NetworkXNoPath:\n    print(\"No path exists between the patient and the condition.\")"
  },
  {
    "question": "Which hospitals/organizations act as major hubs in terms of degree centrality, serving the most diverse patient populations?",
    "code": "import random\n\n# Create a subgraph for organizations and patients\nH = nx.DiGraph()\norganization_nodes = [n for n in G.nodes if n.startswith(\"organizations/\")]\n\n# Randomly sample 10 organization nodes to limit the computation\nsampled_organizations = random.sample(organization_nodes, min(10, len(organization_nodes)))\n\nfor org in sampled_organizations:\n    H.add_node(org)\n    # Find encounters connected to the organization\n    for encounter in G.neighbors(org):\n        if encounter.startswith(\"encounters/\"):\n            # Find patients connected to the encounter\n            for patient in G.neighbors(encounter):\n                if patient.startswith(\"patients/\"):\n                    H.add_node(patient)\n                    H.add_edge(org, patient)\n\n# Calculate degree centrality for organizations\ndegree_centrality = nx.degree_centrality(H)\n\n# Find the organization with the highest degree centrality\nmax_org = max(degree_centrality, key=degree_centrality.get) \n\norg_name = G.nodes[max_org].get('NAME', 'Unknown')\n\nresult = {\n    'organization_id': max_org,\n    'organization_name': org_name,\n    'degree_centrality': degree_centrality[max_org]\n}"
  },
  {
    "question": "Are there outlier patients who receive an unusually high number of procedures or medications compared to others?",
    "code": "import numpy as np\n\n# Step 1: Identify patient nodes\npatient_nodes = {n for n in G.nodes if n.startswith(\"patients/\")}\n\n# Step 2: Create a mapping of patients to the number of procedures and medications\npatient_procedure_count = {patient: 0 for patient in patient_nodes}\npatient_medication_count = {patient: 0 for patient in patient_nodes}\n\n# Step 3: Count the number of procedures and medications for each patient\nfor patient in patient_nodes:\n    for neighbor in G.neighbors(patient):\n        if neighbor.startswith(\"procedures/\"):\n            patient_procedure_count[patient] += 1\n        elif neighbor.startswith(\"medications/\"):\n            patient_medication_count[patient] += 1\n\n# Step 4: Calculate the mean and standard deviation for procedures and medications\nprocedure_counts = np.array(list(patient_procedure_count.values()))\nmedication_counts = np.array(list(patient_medication_count.values()))\n\nprocedure_mean = np.mean(procedure_counts)\nprocedure_std = np.std(procedure_counts)\nmedication_mean = np.mean(medication_counts)\nmedication_std = np.std(medication_counts)\n\n# Step 5: Identify outliers (more than 2 standard deviations from the mean)\noutlier_patients_procedures = []\noutlier_patients_medications = []\n\nfor patient, count in patient_procedure_count.items():\n    if count > procedure_mean + 2 * procedure_std:\n        patient_info = G.nodes[patient]\n        patient_name = f\"{patient_info.get('FIRST', '')} {patient_info.get('LAST', '')}\".strip() or 'Unknown'\n        outlier_patients_procedures.append({\"id\": patient, \"name\": patient_name, \"count\": count})\n\nfor patient, count in patient_medication_count.items():\n    if count > medication_mean + 2 * medication_std:\n        patient_info = G.nodes[patient]\n        patient_name = f\"{patient_info.get('FIRST', '')} {patient_info.get('LAST', '')}\".strip() or 'Unknown'\n        outlier_patients_medications.append({\"id\": patient, \"name\": patient_name, \"count\": count})\n\n# Step 6: Compile results\nresult = {\n    \"procedure_outliers\": outlier_patients_procedures,\n    \"medication_outliers\": outlier_patients_medications\n}\n\nresult"
  },
  {
    "question": "What is the most critical insurance provider in the network, i.e., removing it would cause the most disruptions in patient care? Use Maximum Flow algorithm. ",
    "code": "import networkx as nx\n\n# Create a subgraph with only payers, patients, and encounters\nH = nx.DiGraph()\n\n# Add nodes for payers and patients\nfor node in G.nodes:\n    if node.startswith(\"payers/\") or node.startswith(\"patients/\"):\n        H.add_node(node)\n\n# Add edges for encounters\nfor u, v in G.edges:\n    if (u.startswith(\"payers/\") and v.startswith(\"encounters/\")) or (u.startswith(\"encounters/\") and v.startswith(\"patients/\")):\n        H.add_edge(u, v, capacity=1)\n\n# Calculate the flow for each payer to all patients\npayer_flow_impact = {}\nfor payer in H.nodes:\n    if payer.startswith(\"payers/\"):\n        total_flow = 0\n        for patient in H.nodes:\n            if patient.startswith(\"patients/\"):\n                flow_value, _ = nx.maximum_flow(H, payer, patient)\n                total_flow += flow_value\n        payer_flow_impact[payer] = total_flow\n\n# Find the payer with the maximum flow impact\nmost_critical_payer = max(payer_flow_impact, key=payer_flow_impact.get)\nmost_critical_payer_name = G.nodes[most_critical_payer].get(\"NAME\", \"Unknown Payer\")\n\nresult = f\"The most critical insurance provider is {most_critical_payer} (Name: {most_critical_payer_name}) with a total flow impact of {payer_flow_impact[most_critical_payer]} disruptions.\""
  }
]
